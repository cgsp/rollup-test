## 1、简单介绍下自己吧

## 2、es6 的 map、set、reduce

- reduce 的入参是什么，如第一个参数是 callback，callback 的参数有哪四个，顺序是怎样的；第二个参数是什么
- map、set 的常见 API 是什么，怎么获取 set 的长度

## 3、this 的指向

### 核心就是：哪个对象调用的这个函数，函数里面的 this 就指向哪个对象，也就是函数的调用方

1. 全局作用域或者普通函数调用，this 指向 window（非严格模式 this 指向 window，严格模式 this 可能是 undefined）（let 声明的变量或者 var 声明的变量，结果不一样）
2. 对象函数调用，指向当前对象
3. 构造函数或者构造函数原型对象，this 指向构造函数的实例
4. 箭头函数调用（箭头函数的 this 指向创建时候的指向，也就是上层作用域的 this）
5. call、apply、bind 改变 this 指向
6. 当代码被内联 on-event 处理函数调用时，它的 this 指向监听器所在的 DOM 对象
7. 当函数（非箭头函数），被用作事件处理函数时，它的 this 指向触发事件的元素

## 4、解释一下 call、apply、bind 的使用场景，及实现原理

### 使用：

1. 当使用一个函数，需要改变 this 指向的时候，就可以考虑 call、apply、bind 了
2. 上述 call, apply, bind 的第一个参数，都可以设置 null 或者 undefined，这么设置的话，this 指向当前执行环境的上下文
3. 上述 call, apply, bind 的第一个参数，都可以设置数字、布尔或 string，这样的话，this 分别指向 Number、Boolean、String 对象
4. call、apply、bind 的参数，都可以只有一个参数(也就是第一个参数)
5. js 中，每个 Function 对象，都有一个 call 方法，也有一个 apply 方法，和 bind 方法
6. apply 和 call 方法，是立即执行；bind 方法，是返回一个函数，方便后续调用
7. bind 方法，可以预设参数

### 原理：

- 原理 1：https://blog.csdn.net/weixin_39147099/article/details/84564582
- 原理 2：https://www.jianshu.com/p/473a86d509b9

```js
Function.prototype.call2 = function (context) {
  var context = context || window
  context.fn = this
  var args = [...arguments].slice(1)
  var result = context.fn(...args)
  delete context.fn
  return result
}

Function.prototype.apply2 = function (context) {
  var context = context || window
  context.fn = this
  var args = arguments[1]
  var result = context.fn(...args)
  delete context.fn
  return result
}

Function.prototype.bind2 = function (context) {
  var self = this
  var args = [...arguments].slice(1)
  return function () {
    return self.apply2(context, args)
    // 或者
    //return self.apply(context, args)
  }
}
```

## 5、微任务、宏任务

- https://www.cnblogs.com/jiangyuzhen/p/11064408.html
- https://blog.csdn.net/qq_41681425/article/details/85775077
- https://www.jianshu.com/p/d08e235e17af
- https://www.jianshu.com/p/75107522813f
- https://www.jianshu.com/p/2a5954b78ff5
- https://blog.csdn.net/namechenfl/article/details/99623700

```js
console.log('1')

async function async1() {
  console.log('2')
  await setTimeout(() => {
    console.log('3')
  }, 0)
  console.log('4')
}

setTimeout(() => {
  console.log('5')
}, 0)

async1()

new Promise(function (resolve) {
  console.log('6')
  resolve()
}).then(function () {
  console.log('7')
})

console.log('8')
```

## 6、从输入 url 到最终的页面显示，会经历什么过程，越详细越好，做过哪些性能优化

### 过程：

1. DNS 解析
2. TCP 连接
3. http 的请求与相应
4. 浏览器判断状态码，如果是 200，就继续解析，如果是 400 或 500 的话就报错，300 重定向（有一个重定向计数器，超过一定次数，也会报错，避免多次重定向）
5. 浏览器开始解析文件，如果是 gzip 的话，先解压
6. 文件解压、解码后，开始渲染
7. 根据 html 构建 DOM 树，根据 css 构建 CSSOM 树
8. 遇到 script 的话，首先判断是否有 async 或者 defer 属性，如果没的话，就会阻塞 html 渲染流程，直到 js 下载并执行完毕之后，才会继续渲染 html；如果有 aysnc，渲染 html 的时候，会并行下载并执行 js；如果有 defer 的话，会下载 js 并等 html 解析完成之后，才会执行 js
9. html 完全加载和解析后，会触发 DomContentLoaded 事件
10. DOM 树和 CSSOM 树构建完成之后，会生成 Render 树，然后页面的元素的布局、样式等就确定了
11. 生成 Render 树的过程中，浏览器开始调用 GPU 绘制、合成图层，将图层显示在屏幕上

### 性能优化：

1. 从输入 URL 到最终的网页显示，涉及到网络层面的，主要有三个过程，DNS 解析、TCP 连接，HTTP 请求/响应，
2. DNS 解析、TCP 连接，前端可做的事情，是比较少的，主要是服务端和运维层面的事情，例如，智能 DNS 解析，减少 DNS 查询，提供访问速度最快的 IP 地址回来
3. HTTP 的请求/响应优化，才是前端性能优化的核心，主要分两个大的方面：减少请求次数、降低单次请求时间
4. 合理利用 HTTP 缓存（强缓存、协商缓存）
5. CDN 降低网络拥塞、就近访问
6. 避免重定向
7. 图片优化（需要 UI 帮助）、图片懒加载、雪碧图
8. 脚本放底部避免 js 阻塞、使用外部 js/css 文件/字体图标等
9. 渲染优化：css 选择器的合理使用、尽量重绘减少重排、减少 dom 操作
10. 尽量重绘，减少重排:
    Dom 变量操作完之后，尽量缓存；
    在循环中操作字符串，最后再操作 dom;
    使用文档碎片 documentFrament；
    不要将尺寸和位置的读与写放在一个语句里面；
    样式如果是重排得到的，尽量缓存，避免再次重排；
    不要直接修改 style，而是通过 class 一次性改变；
    requestAnimationFrame 的使用；
    某些场景下，用 vis:hidden 代替 dib:none；
11. 事件的优化：
    避免事件多次绑定，页面卸载的时候，解除事件的绑定等；
    可以使用事件委托，避免循环给每个元素绑定事件；
    频繁触发的事件，注意使用节流与防抖（）
12. 长列表渲染
13. 少用 iframe(会阻塞页面加载)
14. 在 IE 中用@import 与在底部用<link>效果一样，所以最好不要用它

### 首屏优化：

1. gzip 压缩、css 压缩、js 压缩、图片压缩
2. 路由懒加载，主 js 切割、treeShaking
3. css 前置
4. js 后置，尽量不要首屏放置 js 内联脚本
5. 首屏同步渲染 html，后续的滚屏再采用异步请求数据和渲染 html
6. 首屏服务端渲染 SSR
   7、骨架屏

## 7、lodash get get({a: { b: null}}, 'a.b', 3) => 3 function get(target, path, defaultValue){}

## 8、对 ajax 的函数$.ajax 进行二次封装，支持参数 maxRetryTimes，最大重传次数，例如：当 maxRetryTimes 为 2，ajax 调用失败 2 次后，再进入 fail 回调，如果只有 1 次失败，第二次成功，则直接返回成功的回调

function alipayAjax(url, options) {}

```js
function alipayAjax(url, options) {
  const maxRetryTimes = options.options || 1
  let nowFaliTimes = 0
  const data = options
  return new Promise((resolve, reject) => {
    function _temp(url, data) {
      $.ajax({
        url,
        data,
        success(res) {
          resolve(res)
        },
        fail(err) {
          nowFaliTimes++
          if (nowFaliTimes < maxRetryTimes) {
            _temp(url, data)
          } else {
            reject(err)
          }
        },
      })
    }

    _temp(url, data)
  })
}
```

## 9 前端安全

以下方法存在安全漏洞，请对其进行攻击，执行 alert(1)如何解决这个漏洞？

```js
//sample.com/?url=http%3A%2F%2FsampleImage
url: http: var search = querySearch(locaiton.href)
var content = '<img src = "' + search.url + '"/>'
document.getElementById('J_Container').innerHTML = content
```

```js
let content =
  '<img src = "https://f12.baidu.com/it/u=508912919,3514615327&fm=173&app=49&f=JPEG?w=640&h=355&s=D20229E3445191DC10C034A203003090&access=215967316" onerror="this.onload()" onload="alert(1)"/>'
const reg = /(<img)([^>]*)(onerror="[^>]*")([^>]*)(onload="[^>]*")(\/>)/
content = content.replace(reg, '$1$2$4$6')

console.log(content)

document.getElementById('J_Container').innerHTML = content
```

## 10 http 缓存字段，列举一下

1. http 缓存机制是 web 性能优化的重要手段
2. 缓存相关的信息，放在报文的 header 中，如果缓存名字，只返回报文 header，报文 body 不需要返回，因此，加载速度得到了提高
3. 强缓存如果生效，不需要和服务器发生交互
4. 协商缓存，无论是否生效，都需要和服务器发生交互
5. 强缓存与协商缓存可以同时存在
6. 强缓存的优先级高于协商缓存，如果强缓存生效，直接使用缓存，不再对比协商缓存的规则
7. 强缓存 Expires / Catch-Control，Expires 是 http1.0 的东西，现在主要用 Catch-Control
8. Catch-Control 取值的区别：private、public、no-catch、max-age、no-store
9. 协商缓存：Last-Modified（res）/ IF-Modified-Since（req），Etag（res）/ If-None-Match（req）

## 11 跨域方案

浏览器的同源保护策略：协议、域名、端口，有一个不一样，就是跨域

1. jsonp 方式，缺点：只能发送 get 请求
2. 服务端开启允许跨域
3. 反向代理
4. document.domain+iframe 跨域：父子页面设置相同的 domain，父页面 iframe 加载子页面，子页面 window.parent.xx 的方式获取父页面的变量
5. hash+iframe 跨域：a 页面 iframe 加载 b 页面，a 页面获取 b 页面的 iframe，然后通过 hash 改变 src，b 页面监听 hashchange 变化事件，获取参数
6. window.name+iframe 跨域
7. postMessage 方式：postMessage(数据，目标域名)，目标域名监听 message 事件
8. WebSocket 本身允许跨域通讯

## 12 cors 跨域，一般需要设置哪些头

1. 允许哪些域名
2. 允许哪些方法
3. 允许头里面有哪些值
4. option 请求的有效期等，可以再问下，哪些情况下，可以出发 option 请求

## 13 webpack 里面，处理 css 的一般有哪些 loader

postcss-loader 进行预处理（如 autoprefix 等），sass-loader 将 sass 语法变为 css 语法，css-loader 分析文件之间的依赖关系做合并等，style-loader（测试环境，生产 style 标签挂在 head 中，生产环境用 miniCssExtractplugin.loader，将其独立打包）

## 14 webpack 里面，如果将命令行中的环境变量，注入 app 中

webpack.DefinePlugin

## 15 手机端做的多吗，列举一些常见的兼容性问题

### 现象一：

1. 软键盘弹起，页面 webview 的高度：
   android:高度变小，变为原高度-软键盘高度
   ios:高度不变，页面整体往上滚

2. 软键盘收起，页面 webview 的高度：
   android: 软键盘收起，输入框不失去焦点
   ios: 软键盘收起，输入框失去焦点
   部门 ios 上的微信：软键盘收起，输入框失去焦点，但是页面没回到底部

3. 第一次进入页面，让第一个输入框直接聚焦
   安卓手机可以自动聚焦，但是没办法自动弹起软键盘；
   苹果手机因为安全机制，没办法自动聚焦，也没办法自动弹起软键盘

### 现象一兼容措施：

1. android 监听页面高度变化，判断失去焦点
2. ios 监听输入框的 blur，判断失去焦点
3. 上述判断软键盘弹起后，让页面的可编辑且激活的元素 document.activeElement，定时器延迟，滚动到页面的可视区（activeElement.scrollIntoView）
4. 部分 ios 上的微信兼容（软键盘收起，输入框失去焦点，但是页面没回到底部）：微信官方做了兼容，滚动页面到底部即可：
   window.scrollTo(0, Math.max(document.body.clientHeight, document.documentElement.clientHeight))
5. 针对部分机型软键盘遮挡输入框的情况，需要强行增加页面高度，加 paddingBottom 的方式，让 activeElement 滚动
6. ios 设备，输入框弹起后，pof 失效，输入框跟着页面跑，因此，不能用 pof 布局，需要用 poa 布局（也有些人，软键盘弹起设置 poa，软键盘收起设置 pof）
   7 .main 里面套 A 和 B，A 下面预留 60px 的高度，B 里面放输入框；main 设置 por，B 设置 poa，放在 main 底部，A 里面做滚动（-webkit-overflow-scrollling:touch 增加流畅度）
7. 部分机型输入框无光标闪动：input: -webkit-user-select:none;

### 现象二数字软键盘：

### 现象二兼容措施：

1. <input type="tel" novalidate="novalidate" pattern="[0-9]*">
2. pattern="\d\*"无效
3. input 不做校验，因为 input 自带的校验兼容性很差，校验交给 js 来做

## 16 手机端适配问题

1. js 动态修改 rem 适配
   var rate = parseFloat(getComputedStyle(document.documentElement, false)['fontSize']) / 16

// 750 设计稿
document.documentElement.style.fontSize = 100 \* ( clientWidth / 750 ) / rate + 'px';

监听 resizeEvent 事件动态设置 html 的 font-size
resizeEvent ='orientationchange' in window ? 'orientationchange' : 'resize'

2. media 动态修改 rem 适配
   @media screen and (min-width: 320px) {html{font-size:50px;}}
   @media screen and (min-width: 360px) {html{font-size:56.25px;}}

3. viewport 适配
   //获取 meta 节点
   var metaNode = document.querySelector('meta[name=viewport]');

//定义设计稿宽度为 375
var designWidth = 375;

//计算当前屏幕的宽度与设计稿比例
var scale = document.documentElement.clientWidth / designWidth;

//通过设置 meta 元素中 content 的 initial-scale 值达到移动端适配
meta.content = "initial-scale=" + scale + ",minimum-scale=" + scale + ",maximum-scale=" + scale + ",user-scalable=no";

4. vw（注意是 vw，不是 vh）方式适配
   工具化实现的时候，可以借助 postcss 的插件 postcss-px-to-viewport,这样可以直接在 css 里面写 px，自动转为 vw

## 17 点击 300ms 延迟、手机端点击穿透问题

点击 300ms 延迟的原因：

1. 当初 safari 浏览器为了做一个双击缩放的功能，特意设置了单次点击 300ms 的延迟，后来，其他浏览器也实现了这个功能
2. 点击后 300ms 延迟，这个问题，现在很多浏览器已经移除了，其实不管也行
   解决方案：
3. 页面禁用缩放<meta name="viewport" content="user-scalable=no">禁止了一切缩放
4. 更改默认的视口宽度 <meta name="viewport" content="width=device-width">，禁掉了默认的双击缩放，但是用户仍然可以双指缩放
5. 一些库，如 fastclick、hammerjs、touchjs，检测 touchend 事件，模拟一个 click 事件，并把 300ms 之后真正的 click 事件阻止掉（fastclick 全局劫持了点击事件，某些 app 的 webview 情况下，会引发如点击音频无法播放等情况）
   4、通过 touchStart 和 touchEnd 来模拟

点击穿透现象主要有 3 种：

1. 点击穿透问题：点击蒙层（mask）上的关闭按钮，蒙层消失后发现触发了按钮下面元素的 click 事件，蒙层的关闭按钮绑定的是 touch 事件，而按钮下面元素绑定的是 click 事件，touch 事件触发之后，蒙层消失了，300ms 后这个点的 click 事件 fire，event 的 target 自然就是按钮下面的元素，因为按钮跟蒙层一起消失了
2. 跨页面点击穿透问题：如果按钮下面恰好是一个有 href 属性的 a 标签，那么页面就会发生跳转，因为 a 标签跳转默认是 click 事件触发，所以原理和上面的完全相同
3. 另一种跨页面点击穿透问题：这次没有 mask 了，直接点击页内按钮跳转至新页，然后发现新页面中对应位置元素的 click 事件被触发了，和蒙层的道理一样，js 控制页面跳转的逻辑如果是绑定在 touch 事件上的，而且新页面中对应位置的元素绑定的是 click 事件，而且页面在 300ms 内完成了跳转，三个条件同时满足，就出现这种情况了
4. 非要细分的话还有第四种，不过概率很低，就是新页面中对应位置元素恰好是 a 标签，然后就发生连续跳转了。。。诸如此类的，都是点击穿透问题

如何解决点击穿透:

1. 使用 fastclick 等库
2. ios，为元素绑定 touchend 事件，并在事件中执行 e.preventDefault
3. 安卓，监听上面元素的 touchStart 事件，一旦触发，就设置下面元素的 style.pointEvents=’none’,然后定时器 350ms 之后，style.pointEvents=’all’再恢复
4. 给元素的消失做一个 fade 的动画效果，动画时间大于 300ms

Tap 事件的原理：
tap 事件的原理其实是源于触摸 touch 事件,在移动触摸事件就是在同个点触发,及 touchmove 的距离距离 touchstar 的距离为 0,并且点击的时间不超过某个设定的时间值,超过该时间值的话,就属于长按了

ios 点击无效果：curson:point;

## 18 react 的生命周期、父子组件初次加载、更新时候生命周期各自顺序

## 19 react 的 fiber

## 20 正则 trim 实现

```js
'  abc  '.replace(/^\s+|\s+$/g, '')
```

## 21 正则实现 3 位一个逗号

```js
'abcde'.replace(/(.{3})/g, '$1\.')，然后，再判断下，最后一位是否是.，是的话，slice(0, -1)
```

## 22 二数之和

方式 1：indexOf 法，利用这个 api 的第二个参数

```js
const twoSum = (nums, target) => {
  if (Object.prototype.toString.call(nums) !== '[object Array]') return []
  if (nums.length < 2) return []

  const len = nums.length
  const res = []

  for (let i = 0; i < len; i++) {
    const dis = target - nums[i]
    const disIndex = nums.indexOf(dis, i + 1)
    if (disIndex > -1) {
      // 不能直接return res.push(disIndex, i),这样返回的是2
      res.push(disIndex, i)
      return res
    }
  }

  return []
}
```

方式 2：hash，空间换时间

```js
const twoSum = (nums, target) => {
  // 数据类型检测
  if (Object.prototype.toString.call(nums) !== '[object Array]') {
    return []
  }

  // 数组长度，如果小于2，直接返回[]
  if (nums.length < 2) {
    return []
  }

  // const res = []
  const hash = {}

  // 寻找差值，差值在数组中存在
  // nums.indexOf(dis) > i 避免重复
  for (let i = 0, len = nums.length; i < len; i++) {
    const dis = target - nums[i]
    if (hash[dis] !== undefined) {
      // res.push(hash[dis], i)
      // break
      return [hash[dis], i]
    } else {
      hash[nums[i]] = i
    }
  }

  return res
}

console.log(twoSum([2, 7, 11, 5], 9))
```

## 23 爬楼梯问题

方式 1：跟新

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
  if (n < 4) return n
  let prev1 = 2,
    prev2 = 3
  for (let i = 4; i <= n; i++) {
    result = prev1 + prev2
    prev1 = prev2
    prev2 = result
  }
  return result
}

console.log(climbStairs(5))
```

方式 2：dp

```js
var climbStairs = function (n) {
  const dp = []
  dp[1] = 1
  dp[2] = 2
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]

```

## 24 项目问题
